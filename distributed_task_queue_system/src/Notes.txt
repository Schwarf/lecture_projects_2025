Redis (like post office):
    Role: Acts as the message broker and result backend.
    Functionality:
        Message broker: Queues and stores the tasks that need to be done. It manages the incoming tasks and maintains the queue, ensuring that tasks are ready to be fetched and processed by (Celery) workers.
        Result backend: Stores the results of completed tasks, allowing other parts of the application or other applications to retrieve these results later.

Celery (postal workers, picks up mail and delivers(executes tasks) it:
    Role: Distributed task queue and worker management system.
    Functionality:
        Task distribution: Responsible for distributing these tasks across available workers. When scaling up by adding more workers, Celery efficiently distributes tasks among them based on their availability and capability.
        Task execution: Workers pick up tasks from the Redis queue and execute them. This is where the actual task code (the functions you define and decorate with @app.task) is run.
        Worker management: Celery manages the lifecycle of these workers, including their creation, the work they do, handling failures, and their graceful shutdown.